const fs = require('fs');
const { jParse }  = require('./jsonParse');

const fileHashParser = (path) => {
    //get json file
    const pathToFile = path || './src/utils/fileHashes.json';
    if (!fs.existsSync(pathToFile)) {
        throw new Error(`File not found: ${pathToFile}`);
    }

    let fileData;
    //read file
    try {
        fileData = fs.readFileSync(pathToFile, 'utf8'); 
    } catch (err) {
        console.error('Error reading file:', err);
    }
    let fileHashes = jParse(fileData);

    let keys = Object.keys(fileHashes);
    if (keys.length === 0) {
        throw new Error(`No hashes found in file: ${pathToFile}`);
    }

    //loop thorugh the keys and sort only the ones we want into new json object
    let sortedHashes = {};
    let map = {};
    keys.forEach(key => {
        // filter for the updated public js files and we want to exclude the minified files we are looking for hashes on the edited files and path to those files (if dev)
        if (key.startsWith('public/js/') && !key.startsWith('public/js/min/') && key.endsWith('.js')) {
            let k = key.split('/').pop(); // Get the file name
            sortedHashes[k] = {};
            sortedHashes[k].hash = fileHashes[key].hash;   
            //in production we only need the hash because we will serve all files from the minified folder which will be generated by the build process
            // in development we want the full path to the file so we can load it directly
            if(process.env.NODE_ENV == 'development') {
                sortedHashes[k].path = key.replace('public/js/', ''); // Store the full path in development mode
            }
        }
        if(key.indexOf('sw.js') !== -1) {
            sortedHashes['sw.js'] = {};
            sortedHashes['sw.js'].hash = fileHashes[key].hash;
            sortedHashes['sw.js'].path = 'sw.js'; // Store the full path which is just 'sw.js'
        }
    });

    return sortedHashes;
}


module.exports = { fileHashParser };